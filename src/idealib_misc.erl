%%
%% $Id: $
%%
%% Module:  misc -- description
%% Created: 31-DEC-2012 18:45
%% Author:  tmr
%%

-module (idealib_misc).
-export ([
  ensure_app/1,
  uuidv4str/0,
  re_esc/1,
  get_priv_dir_item/2,
  post_init/2, post_init/3, post_init_internal/3,
  implements/2
]).

%% @doc Ensure the `App' is running.
-spec ensure_app (App::atom ()) -> ok | {error, any ()}.
ensure_app (App) ->
    case application:start (App) of
        ok -> ok;
        {error, {already_started, App}} -> ok;
        {error, _} = Error -> Error;
        WhateverError -> {error, WhateverError}
    end.

%% @doc Check if the `Module' implements `Behavior' callbacks.
-spec implements (Module::atom (), Behavior::atom ()) -> boolean ().
implements (Module, Behavior) ->
  Exports = case catch (Module:module_info (exports)) of
    {'EXIT', _} -> [];
    Ex0         -> Ex0
  end,
  Callbacks = case catch (Behavior:behaviour_info (callbacks)) of
    {'EXIT', _} -> [];
    Cbks0       -> Cbks0
  end,
  %% PMods have autogenerated `new' and `instance' methods
  %% and all the exported functions have arity lifted up by one.
  PModArityShift = case lists:keyfind (new, 1, Exports) /= false andalso
                        lists:keyfind (instance, 1, Exports) /= false of
    true  -> 1;
    false -> 0
  end,
  Fun = fun ({Name, Arity}, Acc) ->
    Acc andalso lists:member ({Name, Arity + PModArityShift}, Exports)
  end,
  %% XXX: should exit on first "false" occurence
  lists:foldl (Fun, true, Callbacks).

%% @doc UUIDv4 string generator.
uuidv4str () ->
  <<U0:32, U1:16, _:4, U2:12, _:2, U3:30, U4:32>> =
    crypto:rand_bytes (16),
  <<Ux0:32, Ux1:16, Ux2:16, Ux3:16, Ux4:48>> =
    <<U0:32, U1:16, 4:4, U2:12, 2#10:2, U3:30, U4:32>>,
  lists:flatten (io_lib:format (
    "~8.16.0b-~4.16.0b-~4.16.0b-~4.16.0b-~12.16.0b",
    [Ux0, Ux1, Ux2, Ux3, Ux4])).

%% @doc regex pattern escaper.
re_esc ({re_pattern, _} = Pat) -> Pat;
re_esc ([]) -> [];
re_esc (X) when is_binary (X) ->
  list_to_binary (re_esc (binary_to_list (X)));
re_esc ([H|T]) when H >= $0, H =< $9; H >= $a, H =< $z; H >= $A, H =< $Z ->
  [H|re_esc (T)];
re_esc ([H|T]) -> [$\\, H|re_esc (T)].

%% @doc Get full path of item stored in private directory.
get_priv_dir_item (App, Name) ->
  case code:priv_dir (App) of
    {error, bad_name} ->
      case filelib:is_dir (filename:join (["..", priv])) of
        true -> filename:join (["..", priv, Name]);
        _    -> filename:join ([priv, Name])
      end;
    Dir -> filename:join (Dir, Name)
  end.


%% @doc Wait for the `App' to start and run `Fun' function finally.
post_init (App, Fun) ->
  post_init (App, Fun, 500).
post_init (App, Fun, TimeOut) ->
  spawn (?MODULE, post_init_internal, [App, Fun, TimeOut]).

%% @doc INTERNAL PURPOSES ONLY (`post_init/3').
post_init_internal (App, Fun, TimeOut) ->
  ilog:info ("~p Waiting for `~p' application...~n", [self (), App]),
  case proplists:is_defined (App, application:which_applications ()) of
    true -> Fun ();
    false ->
      timer:sleep (TimeOut),
      post_init_internal (App, Fun, TimeOut)
  end.


%% EUnit Tests
-ifdef (TEST).
-include_lib ("eunit/include/eunit.hrl").

re_esc_test () ->

  %% Basic
  ?assertEqual ("asdf", re_esc ("asdf")),
  ?assertEqual (<<"asdf">>, re_esc (<<"asdf">>)),
  ?assertEqual ("asdf\\&", re_esc ("asdf&")),
  ?assertEqual (<<"asdf\\(\\@\\)">>, re_esc (<<"asdf(@)">>)),

  ok.

-endif.

%% vim: fdm=syntax:fdn=3:tw=74:ts=2:syn=erlang
